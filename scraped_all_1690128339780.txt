URL: https://webdesign.tutsplus.com/how-to-implement-infinite-scrolling-with-javascript--cms-37055t
Web Design
 JavaScript
How to Implement Infinite Scrolling With JavaScript
Jemima Abu
Last updated Jul 8, 2022
 53 likes
 Read Time: 10 min
JavaScriptScroll Events

In this tutorial, we’ll be looking at a simple implementation for breaking up page content using the infinite scroll method. We’ll use HTML, CSS and vanilla JavaScript to build a performant and accessible version of the infinite scroll feature.

What is Infinite Scrolling?

Infinite scrolling is a feature used to dynamically load more content on a page once a user scrolls to the end of the page.

The concept of infinite scrolling is used to load data from a server in a way that feels “seamless” to a user but doesn’t overload the server by requesting too much data at once.

In a previous tutorial, we implemented a pagination feature which allowed us break up our content into navigable sections known as pages. This tutorial will use a similar implementation.

Benefits of Vanilla JavaScript

A significant benefit of using JavaScript is that our implementation is framework-agnostic i.e. it’s not dependent on any framework so it can be modded to work across all of them.

Also, since we’re building the feature ourselves and not depending on a plugin, we can ensure that the implementation is lightweight and perfectly suited to our needs.

Infinite Scrolling Demo

Here’s a look at the final product, scroll to the bottom of the pen to load more content:

Let’s get started!

1. Markup with HTML

We’ll start by placing the container for our cards on the page. We’ll be adding the cards to the container using JavaScript so the <div> will be empty.

1
	
<div id="card-container"></div>


We also have a loader div for displaying an animation before adding the next batch of cards, and a card-actions div for showing the card count and card total.

1
	
<div id="loader">



2
	
  <div class="skeleton-card"></div>



3
	
  <div class="skeleton-card"></div>



4
	
  <div class="skeleton-card"></div>



5
	
</div>



6
	
<div class="card-actions">



7
	
  <span>Showing 



8
	
    <span id="card-count"></span> of 



9
	
    <span id="card-total"></span> cards      



10
	
  </span>



11
	
</div>

What the loader and card count divs will look like
2. Styling with CSS

The cards we'll be adding to the card-container div will have a classname of 'card'. 

1
	
#card-container {



2
	
  display: flex;



3
	
  flex-wrap: wrap;



4
	
}



5
	


6
	
.card {



7
	
  height: 55vh;



8
	
  width: calc((100% / 3) - 16px);



9
	
  margin: 8px;



10
	
  border-radius: 3px;



11
	
  transition: all 200ms ease-in-out;



12
	
  display: flex;



13
	
  align-items: center;



14
	
  justify-content: center;



15
	
}



16
	


17
	
.card:hover {



18
	
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);



19
	
}



20
	


21
	
.card-actions {



22
	
  margin: 8px;



23
	
  padding: 16px 0;



24
	
  display: flex;



25
	
  justify-content: space-between;



26
	
  align-items: center;



27
	
}


We’ll also create a loading animation for the skeleton cards in the loader div by animating the ::after pseudo-selector:

1
	
#loader {



2
	
  display: flex;



3
	
}



4
	


5
	
.skeleton-card {



6
	
  height: 55vh;



7
	
  width: calc((100% / 3) - 16px);



8
	
  margin: 8px;



9
	
  border-radius: 3px;



10
	
  transition: all 200ms ease-in-out;



11
	
  position: relative;



12
	
  background-color: #eaeaea;



13
	
}



14
	


15
	
.skeleton-card::after {



16
	
  content: "";



17
	
  position: absolute;



18
	
  top: 0;



19
	
  right: 0;



20
	
  bottom: 0;



21
	
  left: 0;



22
	
  transform: translateX(-100%);



23
	
  background-image: linear-gradient(90deg, rgba(255, 255, 255, 0) 0, rgba(255, 255, 255, 0.2) 20%, rgba(255, 255, 255, 0.5) 60%, rgba(255, 255, 255, 0));



24
	
  animation: load 1s infinite;



25
	
}



26
	


27
	
@keyframes load {



28
	
  100% {



29
	
    transform: translateX(100%);



30
	
  }



31
	
}

Advertisement
Accessible Styling

Whenever we’re including an animation on a webpage, it’s important to consider the accessibility implications. Some users may prefer to have no animation at all and we can take that preference into consideration in our styling by using the media rule, prefers-reduced-motion

1
	
@media screen and (prefers-reduced-motion: reduce) {



2
	
  .skeleton-card::after {



3
	
    animation: none;



4
	
  }



5
	
}

3. Functionality With JavaScript

Let’s break down the logic behind infinite scrolling.

Define the limit of the content to be loaded on the page.
Detect when the user has reached the end of the content container.
Load more content once the end of the container has been reached.
If there’s no more content to be loaded, stop the infinite scroll.
Defining Constants

First, let’s get all the elements we’ll need from our DOM:

1
	
const cardContainer = document.getElementById("card-container");



2
	
const cardCountElem = document.getElementById("card-count");



3
	
const cardTotalElem = document.getElementById("card-total");



4
	
const loader = document.getElementById("loader");


Now we need to define our global variables.

We’ll need a value for the max number of cards to be added to the page. If you’re getting your data from a server, this value is the length of the response from the server. Let’s initialise a card limit of 99. 

1
	
const cardLimit = 99;


The cardTotalElem is the element for displaying the max number of cards on the page so we can set the innerHTML to the cardLimit value;

1
	
cardTotalElem.innerHTML = cardLimit;


Then we’ll define a variable for how many cards we want to increase the page by:

1
	
const cardIncrease = 9;


We’ll want to know how many “pages” we’ll have i.e. how many times can we increase the content till we reach the max limit. For example, with our defined cardLimit and cardIncrease variables, we can increase the content 10 times (assuming we’ve already loaded the first 9 elements) until we reach the limit. We’ll do this by dividing the cardLimit by the cardIncrease.

1
	
const pageCount = Math.ceil(cardLimit / cardIncrease);


Then we’ll define a value to determine which page we’re on:

1
	
let currentPage = 1;

Advertisement
Creating a New Card

Now we have all our constants, let’s make a function to add a new card to the card container. We’ll set the innerHTML of our cards to the index value so we can keep track of the number of cards we’re adding.

A fun feature in this demo is that each card has a randomly generated background color.

How to Generate Random Background Colors With JavaScript
Jemima Abu
31 May 2021
1
	
const getRandomColor = () => {



2
	
  const h = Math.floor(Math.random() * 360);



3
	


4
	
  return `hsl(${h}deg, 90%, 85%)`;



5
	
};



6
	


7
	
const createCard = (index) => {



8
	
  const card = document.createElement("div");



9
	
  card.className = "card";



10
	
  card.innerHTML = index;



11
	
  card.style.backgroundColor = getRandomColor();



12
	
  cardContainer.appendChild(card);



13
	
};

Adding Cards to the Container

Now we’ll add our cards to our container using similar functionality to the Pagination tutorial.

First, determine the range of cards to be added to the page. The addCards function will accept a pageIndex parameter, which will update the global currentPage value. If we’re on page 1, we’ll add cards 1 to 9. If we’re on page 2, we’ll add cards 10 to 18 and so on.

We can define that mathematically as:

1
	
const addCards = (pageIndex) => {



2
	
  currentPage = pageIndex;



3
	
  



4
	
  const startRange = (pageIndex - 1) * cardIncrease;



5
	
  const endRange = pageIndex * cardIncrease;



6
	
  



7
	
  for (let i = startRange + 1; i <= currRange; i++) {



8
	
    createCard(i);



9
	
  }



10
	
};


In this function, our start range will always be one less than the value we’re trying to get (i.e. on page 1, the start range is 0, on page 2, the start range is 9) so we’ll account for that by setting the value of our for loop index to startRange + 1.

Detecting When Card Limit is Reached

A limit we’ll have to look out for is the endRange number. If we’re on the last page, we’ll want our end range to be the same as the cardLimit. For instance, if we have a cardLimit of 75 and a cardIncrease of 10 and we’re on page 8, our starting index will be 70 and our endRange value should be 75. 

We’ll modify our addCards function to account for this:

1
	
const addCards = (pageIndex) => {



2
	
  currentPage = pageIndex;



3
	


4
	
  const startRange = (pageIndex - 1) * cardIncrease;



5
	
  const endRange = currentPage == pageCount ? cardLimit : pageIndex * cardIncrease;



6
	


7
	
  for (let i = startRange + 1; i <= endRange; i++) {



8
	
    createCard(i);



9
	
  }



10
	
};


Our demo also includes a cardTotal element that displays the number of cards currently being shown on the page so we’ll set the innerHTML of this element as the end range.

1
	
const addCards = (pageIndex) => {



2
	
  currentPage = pageIndex;



3
	


4
	
  const startRange = (pageIndex - 1) * cardIncrease;



5
	
  const endRange = currentPage == pageCount ? cardLimit : pageIndex * cardIncrease;



6
	
  



7
	
  cardCountElem.innerHTML = endRange;



8
	


9
	
  for (let i = startRange + 1; i <= endRange; i++) {



10
	
    createCard(i);



11
	
  }



12
	
};

Loading Initial Cards

We’ve defined a feature for adding cards to the container so we’ll include a window.onload function to set the initial cards to be added to the page.

1
	
window.onload = function () {



2
	
  addCards(currentPage);



3
	
};

Handling Infinite Scroll

We’ll handle our infinite scroll by increasing the currentPage number to add new cards to the container when we’ve reached the end of the page. We can detect when the end of the page is reached by adding the innerHeight of the window to the scroll value pageYOffset and comparing it to the document offsetHeight which is the total height of the page.

Here’s a visual representation of what this looks like:

Once we’ve reached the end of the page, we want to load a new page by calling our addCards function with currentPage + 1.

1
	
const handleInfiniteScroll = () => {



2
	
  const endOfPage = window.innerHeight + window.pageYOffset >= document.body.offsetHeight;



3
	


4
	
  if (endOfPage) {



5
	
    addCards(currentPage + 1);



6
	
  }



7
	
};


Then we create an event listener for the window scroll and pass our above function into it:

1
	
window.addEventListener("scroll", handleInfiniteScroll);

Performance Optimisation

Since we’re working with the scroll event listener, it’s beneficial to the performance of our webpage to limit the number of calls made. We can slow down the number of calls using a throttle function.

How to Implement Debounce and Throttle with JavaScript
Jemima Abu
12 Jun 2023

We’ll define our throttle function this way:

1
	
var throttleTimer;



2
	


3
	
const throttle = (callback, time) => {



4
	
  if (throttleTimer) return;



5
	


6
	
  throttleTimer = true;



7
	


8
	
  setTimeout(() => {



9
	
    callback();



10
	
    throttleTimer = false;



11
	
  }, time);



12
	
};


and then we pass the throttle function into the handleInfiniteScroll function

1
	
const handleInfiniteScroll = () => {



2
	
  throttle(() => {



3
	
    const endOfPage =



4
	
      window.innerHeight + window.pageYOffset >= document.body.offsetHeight;



5
	


6
	
    if (endOfPage) {



7
	
      addCards(currentPage + 1);



8
	
    }



9
	
  }, 1000);



10
	
};

Stopping Infinite Scroll

At this point, we’ve set up our functions to add more content once the end of the page is reached. Now, let’s make sure our function stops running when there’s no more content to be added i.e. when the cardLimit is reached. 

First, let’s define our removeInfiniteScroll function. In this function, we’ll remove the handleInfiniteScroll function from the scroll event listener and also delete the loader div.

1
	
const removeInfiniteScroll = () => {



2
	
  loader.remove();



3
	
  window.removeEventListener("scroll", handleInfiniteScroll);



4
	
};


Now we’ll modify our handleInfiniteScroll to account for if there’s no more content to be added i.e. we’re on the last page of content.

1
	
const handleInfiniteScroll = () => {



2
	
  throttle(() => {



3
	
    const endOfPage =



4
	
      window.innerHeight + window.pageYOffset >= document.body.offsetHeight;



5
	


6
	
    if (endOfPage) {



7
	
      addCards(currentPage + 1);



8
	
    }



9
	


10
	
    if (currentPage === pageCount) {



11
	
      removeInfiniteScroll();



12
	
    }



13
	
  }, 1000);



14
	
};

Conclusion

And there we have it! We’ve built a performant and accessible implementation of the infinite scroll feature. Check out the complete JavaScript code by hitting the JS tab on the embedded demo below:

Did you find this post useful?
 Yes
 No
Want a weekly email summary?
Subscribe below and we’ll send you a weekly email summary of all new Web Design tutorials. Never miss out on learning about the next big thing.
Sign up
Jemima Abu
Front End Developer
I'm a self-taught front end developer and school-taught systems engineer from Lagos, Nigeria.
I write the kind of articles I'd like to read when trying to learn a new technology or implement a feature.
jemimaabu

URL: https://www.smashingmagazine.com/2016/03/pagination-infinite-scrolling-load-more-buttons/
Christian Holst
mar 1, 2016
0 comments
Infinite Scrolling, Pagination Or “Load More” Buttons? Usability Findings In eCommerce
17 min read
UX, E-Commerce, Usability, UX
Share on Twitter, LinkedIn
ABOUT THE AUTHOR

Christian Holst is the co-founder of Baymard Institute where he writes bi-weekly articles with their research findings on web usability and e-commerce … More about Christian ↬

Email Newsletter
Your (smashing) email

Weekly tips on front-end & UX.
Trusted by 200,000+ folks.

What is the best UX pattern to display products on an e-commerce website: pagination, a “Load more” button or infinite scrolling? At Baymard Institute, we’ve conducted several year-long large-scale usability studies of more than 50+ leading e-commerce websites. We tested (among other things) these three design patterns for loading products, both on desktop and mobile.

What is the best UX pattern to display products on an e-commerce website: pagination, a “Load more” button or infinite scrolling? At Baymard Institute, we’ve conducted several year-long large-scale usability studies of more than 50+ leading e-commerce websites. We tested (among other things) these three design patterns for loading products, both on desktop and mobile.

Further Reading On Smashing:
Infinite Scrolling: Let’s Get To The Bottom Of This
Get the Scrolling Right
Reapplying Hick’s Law of Narrowing Decision Architecture
6 Design Principles To Evaluate Your Product
How To Change User Behavior With UX Design And Psychology

Pagination is still the most popular way to load new items on a website because it ships by default in almost every single e-commerce platform. However, our usability test sessions found “Load more” buttons combined with lazy-loading to be a superior implementation, resulting in a more seamless user experience. We found that infinite scrolling can be downright harmful to usability — in particular, for search results and on mobile. However, it’s not black and white, because the performance of each method varies according to the context of the page.

In this article, we’ll present Baymard Institute’s usability research findings for both “Load more” buttons, infinite scrolling and pagination, including for both mobile and desktop. We’ll see how search results need to be implemented differently from category navigation, along with several pitfalls with implementation and examples from leading e-commerce websites.

More after jump! Continue reading below ↓

Meet Smashing Workshops on front-end & UX, with practical takeaways, live sessions, video recordings and a friendly Q&A. On design systems, UX, web performance and CSS/JS. With Brad Frost, Christine Vallaure and so many others.

Jump to the workshops ↬
The Test Findings

Throughout our large-scale usability study of e-commerce product lists and filtering, numerous test subjects explicitly complained about pagination. Test subjects generally perceived pagination to be slow, and the presence of more than a handful of pagination links would often discourage them from browsing the product list. More importantly, test subjects were observed to browse much less of the total product list than on websites that rely on “Load more” buttons or infinite scrolling. On the upside, they spent relatively more time on the first page of results.

Many subjects used the number of pagination links, seen here on Macy’s, to gauge the total number of results. While pagination links offer more control for jumping to a particular set of results, very few subjects actually used these during testing. Instead, they almost exclusively used the “Next” and “Previous” buttons. (View large version)

With infinite scrolling, sometimes referred to endless scrolling, the user largely experiences the page as if all products are loaded at once (regardless of whether they actually see all of the products), but without the performance penalty of potentially hundreds of products loading. Therefore, when infinite scrolling is implemented well, it can make for an incredibly smooth and seamless experience. The user can just scroll the list of products without any interruption. No interaction is needed — products simply appear as the user scrolls down the page. It should come as no surprise, then, that subjects browsed vastly more products on websites with infinite scrolling than on websites with either pagination or “Load more” buttons. However, initial results received relatively less exposure. Infinite scrolling is, therefore, ideal for quickly showing the breadth of an entire category; but because users aren’t naturally halted when scrolling, they tend to scan more and focus less on individual products on the list.

Notice the length of the scrollbar. On websites with infinite scrolling, test subjects often browsed a hundred or more products, which they virtually never did on websites with pagination and only rarely did on websites with “Load more” buttons. While this proved efficient for the first 50 to 150 products, some subjects would just continue scrolling a list without really focusing on individual products if the list didn’t stop, turning the initial benefit of infinite scrolling into a liability. (View large version)

Infinite scrolling also impedes the user’s access to the website’s footer in some cases. This is one of the major design challenges of infinite scrolling: Because results continually load as the user approaches the bottom of the list, the user will see the footer for a second or two until the next set of results is loaded and suddenly inserted, pushing the footer out of view. If many items are in the list (which is often the case with search and high-level categories), this effectively prevents the user from ever reaching the footer. This can be highly problematic because the footer often holds links to vital help pages, cross-navigation, inspirational category content, and information about customer support, shipping, and returns.

Only a few of the websites tested used a “Load more” button, but they were well received by subjects. In fact, when benchmarking the top 50 US e-commerce websites, we found only 8% use the “Load more” approach. “Load more” is a very simple design that doesn’t burden the user with having to figure out which page to go to, but rather simply asks, “Do you want to see more results?” This makes for a very simple interface and probably the smallest cognitive load possible for on-demand loading of additional items. Subjects generally browsed more products on websites with a “Load more” button than on those with pagination links, but because loading additional products still required an active choice and click, subjects did tend to read the displayed items much more closely than on websites with infinite scrolling.

On websites with “Load more” buttons, like American Eagle Outfitters, users explored more products than on websites with pagination, but they didn’t quickly scan as they did with infinite scrolling. Furthermore, product exploration was observed to be significantly easier because users were able to inject additional products into the current list. (View large version)
Urban Outfitters (View large version)

One of the benefits of the “Load more” and infinite scrolling implementations is that the product list grows, instead of results being replaced. “Load more” allows the user to compare more easily products across an entire list. Having one consolidated list of goods made it significantly easier for users to evaluate which products would be the best to navigate to and, consequently, increased the overall product discoverability rate.

So, which loading method should you use? Ideally, you should use multiple variations of “Load more,” as it turns out. Testing showed that no single method was perfect in all instances; different contexts warranted one of three different implementations of the “Load more” approach. We’ll cover these three variations for the remainder of this article:

For categories, use a combination of “Load more” and lazy-loading.
For search, use the “Load more” button, ideally with a dynamic number of results returned based on relevancy scores.
On mobile, use the “Load more” button, but loading a lower number of products by default.

Note: These findings are from testing e-commerce websites. Performance might vary on other types of websites.

“Load More” For Categories

In our large-scale usability study on e-commerce home page and category navigation, we found the optimal solution for loading new products in categories to lie at the intersection of the “Load more” button and infinite scrolling in the form of lazy-loading: Show 10 to 30 products on initial page load, and then lazy-load another 10 to 30 products, until you reach 50 to 100 products, and then display a “Load more” button; once that button is clicked, load another 10 to 30 products, and resume lazy-loading until the next 50 to 100 products have loaded, at which point show the “Load more” button once again. The “Load more” button threshold of 50 to 100 items determines when to interrupt the user, while the lazy-loading threshold is merely a performance optimization to reduce loading time and server load.

Note that the number of products to load is purposely a range here. Testing shows that the ideal number will depend on your website’s context and industry. For lists with more spec-driven products (most consumer electronics, hardware, parts and supplies), use the lower range. In contrast, testing showed that users can deal with a higher number of items when the list contains more visual products (apparel, furniture, decor, etc.)

(For lazy-loading, a heap of code and plugins is available as a point of departure, just two of which are Mika Tuupola’s Lazy Load for jQuery and LazyLoad XT.)

Crutchfield implements a “Load more” button in conjunction with lazy-loading. First, 20 products load by default; once users scroll to the 10th product, Crutchfield lazy-loads an additional 20 products. After the 40th product, the user is presented with a “Load more” button. (View large version)

This way, pages load quickly because very few products are loaded initially. More importantly, for small and medium-sized categories, lazy-loading will let the user browse the breadth of products without interruption. In effect, it will be as though “View all” is enabled for most well-defined categories — in particular, when filters are applied. For longer lists, the user will be met with a “Load more” button, which makes it very easy to continue viewing more products if the user wishes to do so, but provides a healthy break from scrolling, giving the user to easy access to the footer and giving them a moment to consider whether applying filters would be better than continuing to scroll hundreds of products.

One of the weaknesses of lazy-loading, and infinite scrolling in particular, is that the page’s height continually lengthens; if the user drags the scroll bar to the bottom, they will reach the footer and see it for a second or two as the next items load. The new items will then be appended to the list, and the footer will be pushed down and the scroll bar extended. During testing, this resulted in a jagged page experience. With the “Load more” combination, this is largely resolved because a break comes after just a jump or two. However, if you’re looking to perfect your implementation, consider “faking” the height of the page by multiplying the height of a list item by the number of rows until the next “Load more” button — even if those product rows haven’t loaded yet. This faux page height will give the scroll bar the appropriate space from the beginning and, therefore, is a more accurate representation of the actual height of the list. It also gives the user access to the footer without any jumps whatsoever. And lazy-loading will continue to load products as before — only now they are taking up the empty space instead of extending the page.

“Load More” For Search Results

Due to the open-ended-ness of search, it tends to have far more results than category browsing. In our usability study on e-commerce search, hundreds of search results were not an uncommon sight, and on mass merchant websites, search queries often return thousands of results.

Furthermore, with search, results are sorted by relevance. So, the fifth result is typically a lot more relevant to the user than the hundredth result. This means users shouldn’t have to scan upwards of a hundred products when searching — rather, they should be encouraged to examine the first items carefully. Search results should, therefore, load only 25 to 75 products by default, and infinite scrolling should never be used for the search results. (Interestingly, Etsy’s famous A/B split test of infinite scrolling also documented a significant hit to the search experience.) Pagination or a “Load more” button would be better for search results, then, because they don’t encourage quick scanning of a large number of products, but instead nudge the user to focus more on exploring the first set of results. Indeed, because of the fewer results, lazy-loading isn’t a requirement (but, if implemented for category navigation, may just as well be reused here).

With “Load more,” seen here on L.L. Bean, users get a natural break because the relevance of results decreases (unlike infinite scrolling), but they still have the option to compare the first set of results to the second (unlike with pagination). (View large version)

To take things to the next level, the threshold for how many products are loaded by default may be dynamically adjusted based on the relevancy scores of search results. Most search engines will rank each result with a relevancy score and return those with the highest relevance first. These scores can be used to determine a dynamic threshold that increases or decreases the number of products loaded according to whether the user should be encouraged to scan only the first few results or browse a wider breadth of items.

In practice, this can be done by detecting sudden drops in relevancy scores for the user’s search results and, based on these drops, determining an optimal number of the outcome to be returned for that particular search query. For example, if relevancy scores begin to drop steeply after the first 28 results, then the number of products loaded can be lowered to increase focus on those items. However, if the first 100 results all have very high relevancy scores, then the number of products loaded may be increased to encourage broader exploration.

“Load More” Buttons For Mobile
Pagination links are often difficult to hit because they are placed close together. Additionally, mobile users are averse to waiting for page reloads and prefer to avoid pagination. (View large version)
Infinite scrolling for long product lists can make the footer inaccessible as new results are continually loaded in, constantly pushing down the footer. (View large version)

In our year-long study of mobile e-commerce, we found that pagination links can be tough to tap accurately and will typically result in a new page load. Meanwhile, infinite scrolling proved very effective at getting subjects to explore many products (in fact, test subjects scrolled through more than twice as many products on test websites with infinite scrolling as they did on those with pagination). However, as mentioned, it can make the footer inaccessible. During mobile testing, it rendered vital mobile footer links — such as “Desktop site,” “FAQ” and “Shipping,” general cross-navigation, and similar elements — inaccessible to the test subjects, who all had clear expectations of these links being available in the footer.

A “Load more results” button, as used on Lowe’s, offers many of the benefits of infinite scrolling while keeping the footer accessible. (View large version)

The best solution, therefore, is to have a single large “Load more” button at the end of the product list. However, mobile come with some unique constraints:

Less screen real-estate
Because a mobile screen is much smaller, list items will take up a relatively largely portion of the screen, with typically only two to three items being displayed in the list-view layout. Therefore, 50 items would take up many more viewport heights on a mobile device than on a desktop computer. In other words, the user will have to interact (i.e. scroll) a lot more on a mobile device than for a comparable product list on the desktop.
Scrolling constraints
On a touch device, the user can usually scroll only by dragging and swiping with their finger. Contrast this with a desktop, where the user typically has numerous inputs for scrolling, such as the mouse’s scroll wheel (or a trackpad swipe), a draggable UI scrollbar, and various keyboard inputs (the up and down arrows, the page up and down keys, the spacebar, etc.).
Slow scrolling
Furthermore, in our tests, subjects demonstrated less control over continuous product-list scrolling. On the one hand, some would scroll too slowly by having to continually drag their finger across the screen; in this case, a list of even 50 products would take a long time to browse. On the other hand, some would scroll the list too fast because they would inadvertently invoke momentum scrolling by swiping in rapid succession; in this case, they would miss out on a lot of products whizzing by them.
JavaScript events
Finally, the way JavaScript events are fired on most touch devices means that the dynamic lazy-loading technique often can’t be implemented as well. JavaScript events fire only once the user’s scrolling ends; therefore, products can’t be fetched while the user is scrolling, only once scrolling stops.

For these reasons, we’d recommend loading only 15 to 30 products on mobile devices before showing the “Load more” button, and then simply loading them all at once (not lazy-loading).

Key Detail: Back Button Support Through History.PushState

In our seven years of usability testing, we’ve consistently observed how the technical implementation of loading a new page and the user’s expectation of a new page loading don’t always align on e-commerce websites. Dynamically loading content such as overlays, accordions, filters and AJAX-loaded products will often subvert the user’s expectation of how their back button works. (See our full research findings on the user’s back-button expectations.)

The “Load more” method requires careful consideration of back-button behavior. It’s critical that after a user has visited a particular product page from the product list, they are taken back to the same spot on that list upon clicking the browser’s back button. Of the e-commerce websites we benchmarked that have the “Load more” button, over 90% get this wrong. This necessarily impedes the user’s from jumping back and forth between the product list and product pages using the same browser tab — a severe navigational limitation.

Skechers actively addresses the back-button issue by rewriting the URL each time a user clicks the “Load more” button. Consequently, when a user clicks to go back from a product page, they are taken to the correct position in the product list. (View large version)
Skechers (View large version)
Skechers (View large version)

HTML5’s History API allows us to honor the user’s expectation. Specifically, the history.pushState() function enables us to invoke a URL change without reloading the page, thus matching the browser’s back-button behavior to the user’s expectation. The browser will remember the user’s scroll position, but we need to ensure that any “Load more” clicks are loaded by default when the user goes back.

Note that if you don’t have the technical resources to support proper back-button behavior, we recommend not experimenting with “Load more” at all, but rather sticking with the inferior pagination model.

“Load More” Shouldn’t Be Your Top Priority

While the debate over “Load more” versus infinite scrolling versus pagination has been debated for years, the product loading method shouldn’t be the first thing that most e-commerce vendors spend their development resources on.

Over the last seven years, we’ve documented plenty of severe UX issues on the vast majority of e-commerce websites. A selection of these issues have been explored in our past articles here on Smashing Magazine, including those on e-commerce search, category navigation, filtering, checkout and the mobile experience. Many of these issues, which are just as impactful, require significantly less design and technical resources to address than developing a solid “Load more” implementation.

That’s not to say the loading method is not critical. It is, and we observed during testing that it can change product exploration significantly. It just shouldn’t be at the top of the list of changes for most websites that still have plenty of low-hanging fruit that promise a better return on investment. “Load more” is thus reserved for those websites striving for UX perfection.

“Load More” Vs. Infinite Scrolling Vs. Pagination

In short, in our usability testing, the “Load more” button solved the usability issues observed with pagination (whereby users explored less of a product list, and comparison of products across pages of results was difficult), and it solved the severe issues observed with infinite scrolling (whereby users superficially scanned products and were often unable to reach the footer).

However, “Load more” buttons perform better only when the issue with the browser’s back button is dealt with — for example, through history.pushState() — and, ideally, when the implementation is adjusted based on the user’s context. In particular, the following three contextual adjustments were observed to be key to performance:

For category navigation, use a combination of the “Load more” button and lazy-loading. Set the threshold for the “Load more” button to 50 to 100 items.
For search results, use the “Load more” button, but set the threshold to 25 to 75 results only. Ideally, you would dynamically adjust the threshold for each unique list of search results based on any drops in the relevancy scores for the results.
On mobile, use the “Load more” button but set the threshold to 15 to 30 products because of scrolling and screen size issues. Furthermore, because of how JavaScript events fire and the lower threshold, load all products at once, instead of lazy-loading.

You can find all 93 test findings on product list usability in our (not publicly available) report “Product Lists and Filtering.”

 (al)
Explore more on
UX
E-Commerce
Usability
UX
Smashing Newsletter

Tips on front-end & UX, delivered weekly in your inbox. Just the things you can actually use.

Front-End & UX Workshops, Online

With practical takeaways, live sessions, video recordings and a friendly Q&A.

TypeScript in 50 Lessons

Everything TypeScript, with code walkthroughs and examples. And other printed books.

URL: https://www.freecodecamp.org/news/how-to-implement-infinite-scroll-in-next-js/
JANUARY 5, 2023
/
#NEXTJS
How to Implement Infinite Scroll in Next.js with Intersection Observer
Divine Orji

Creators and developers continually come up with new ways to enhance apps and provide value to users.

One feature that's useful for social media and ecommerce apps in particular is infinite scroll. It provides a seamless and intuitive browsing experience by reducing the time it takes to see new content.

This article will teach you how to implement infinite scroll in a Next.js app using JavaScript’s Intersection Observer API.

What is Infinite Scroll?

Infinite scroll is a web design technique that allows your website or app to load more content as a user scrolls down.

For example, suppose your website has many items to display (such as a news feed or product listing). This technique eliminates the need to click through many pages, allowing users to explore and discover new content easily.

It also helps to improve the user experience by reducing the time it takes to load new pages since the content loads dynamically as the user scrolls.

Pagination vs Infinite Scroll - Smashing Magazine

You can implement it in your project using JavaScript’s Intersection Observer API.

What is the Intersection Observer API?

This browser-based API allows you to observe changes in your app’s viewport or a specific intersection between elements.

It works for use cases like lazy-loading, smooth animation transition, and infinite scrolling. You can use this API to detect when certain elements appear on your screen and trigger a function to make changes to the app.

CodeSandbox and GitHub Repo

The complete demo for this article is available on CodeSandbox. You can also check out its source code on GitHub.

Prerequisites

To smoothly follow along, you will need these first:

Knowledge of JavaScript and React.
A GitHub account to generate the starter code and store your code remotely. You also need Git to track changes to your codebase.
Yarn installed on your computer. You need to have Node.js installed on your computer, which comes with NPM for installing Yarn.
Experience with Next.js, while not required, will give you an edge and help you understand this article better.
Familiarity with Tailwind, the CSS framework used in this project. Also not strictly required.
How to Set Up the Project

Click here to generate the starter files for this project in your preferred browser:

After generating the repo, copy its Git URL so you can clone it to your PC:

In your PC’s terminal, run the command below to clone your repo:

git clone theGitUrlOfYourRepo


After successfully cloning the project, install dependencies by running the command below in your project’s terminal:

yarn

# or npm install. But for this demo, yarn is preferred


On completion, run yarn dev in your project’s terminal, and navigate to localhost:3000 on your browser to see the starter UI:

How to Handle Content

For this project, you will get tea images from Unsplash via its public API. So navigate to https://unsplash.com/developers and click on “Register as a developer” or “Login” if you have an Unsplash account:

On successful login, click “Your apps” and “New Application”. Accept the terms of the agreement, then fill out your app’s name and description:

After successfully creating your app on Unsplash, scroll down to copy your Access Key.

Open your project in your preferred code editor and create a .env.local file in its root folder to store your Access Key:

NEXT_PUBLIC_UNSPLASH=yourUnsplashApiAccessKey


In your code editor, navigate to pages/index.js and update the fetchImages function with the code below:

const fetchImages = async () => {
  const response = await fetch(`${BASE_URL}?query=tea&page=${page}`, {
    headers: {
      Authorization: `Client-ID ${process.env.NEXT_PUBLIC_UNSPLASH}`,
    },
  });
  const { results } = await response.json();
  setImages((prev) => [...prev, ...results]);
}; 


Here, you did the following:

Implemented JavaScript’s fetch function to make an HTTP request to Unsplash’s API endpoint. The endpoint contains the BASE_URL, your query, and the current page.
In your fetch function, the options object includes a headers property that specifies an Authorization header with a value of Client-ID ${process.env.NEXT_PUBLIC_UNSPLASH}, which is your API Access Key.
You then parsed your response as JSON and destructured the results property.
Finally, you updated your images state by concatenating the previous value of images with the results array.

In your pages/index.js file, replace // useEffect here with the code below:

useEffect(() => {
  fetchImages();
}, [page]);


Here, you set up useEffect to trigger the fetchImages function whenever page updates.

How to Implement the Intersection Observer API

Navigate to components/ui/Card.js and update useEffect with the code below:

useEffect(() => {
  if (!cardRef?.current) return;

  const observer = new IntersectionObserver(([entry]) => {
    if (isLast && entry.isIntersecting) {
      newLimit();
      observer.unobserve(entry.target);
    }
  });

  observer.observe(cardRef.current);
}, [isLast]);


Here, you set up an Intersection Observer with the useEffect hook. It detects when each Card component becomes visible in the viewport.

When a Card component contains the last element in your images array and is visible (entry.isIntersecting), the Intersection Observer API triggers the newLimit function and stops observing the target element.

The useEffect hook will run whenever the isLast variable changes.

Update the props in your card component to contain newLimit and isLast:

export default function Card({
  creditUrl,
  imgAlt = 'placeholder',
  imgSrc = '/placeholder.jpg',
  shotBy,
  newLimit,
  isLast,
}) {
// code content
}


In your pages/index.js, update <HomeLayout> with the code below:

<HomeLayout>
  {images.map((image, index) => (
    <Card
      key={image.id}
      imgSrc={image.urls.regular}
      imgAlt={image.alt_description}
      shotBy={image.user.name}
      creditUrl={image.links.html}
      isLast={index === images.length - 1}
      newLimit={() => setPage(page + 1)}
    />
  ))}
</HomeLayout>;


Here, you mapped through your images array, rendering a list of Card components that each display the image, the photographer, and the link to the original post on Unsplash.

The isLast prop checks if the current card component is the last one in the images array. It then triggers the newLimit function from your Intersection Observer API to update the page count.

Here is the final result below:

Conclusion

In this article, you learned how to implement infinite scroll in a Next.js app. The capabilities of Intersection Observer API are not limited to infinite scroll and lazy loading. You will discover more as you keep practicing. The resources below are a good starting point.

ADVERTISEMENT
ADVERTISEMENT
ADVERTISEMENT
ADVERTISEMENT
ADVERTISEMENT
ADVERTISEMENT
ADVERTISEMENT
Divine Orji

I am a software engineer passionate about building fast, scalable apps with beautiful user interfaces.

If you read this far, tweet to the author to show them you care. Tweet a thanks

Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as developers. Get started

ADVERTISEMENT

